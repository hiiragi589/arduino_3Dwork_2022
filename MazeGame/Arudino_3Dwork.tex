\documentclass[10pt]{jsarticle}
\usepackage[deluxe]{otf}
\usepackage[utf8]{inputenc}
\usepackage[margin=20truemm]{geometry}
\usepackage{ascmac}
\usepackage{amsmath,amssymb}
\usepackage{mathcomp}
\usepackage{enumerate}

\usepackage{multirow}
\usepackage[dvipdfmx]{graphicx}
\usepackage{url}

\newcommand{\bm}[1]{{\mbox{\boldmath $#1$}}}

\title{Arudino 3D作品 ``Maze Game''}
\author{氏名: 西滉平}
\date{2022年 7月 26日制作}
\begin{document}
\maketitle


\section{コンセプト・システムの仕様}

「3Dビューによる迷路探索ゲーム ``Maze Game''」を作成した.
以降, 本ゲームを「3D迷路ゲーム」と略称で表記する. 
まず, 私が作成したゲームの詳細なコンセプトについて説明する.

\begin{itembox}[l]{3D迷路ゲームのゲームコンセプト}
\begin{itemize}
	\item	ゲームジャンル：迷路探索ゲーム.
	\item	クリア条件：迷路を探索し, すべてのアイテムを集める.
			アイテムは迷路上に点在し, アイテムに接近することでこれらを獲得できる.
	\item	操作方法：ジョイスティックとコリジョンセンサー, 及び基板 (ブレッドボード) の傾きにより操作を行う.
			\begin{description}
			\item[プレイヤーの移動]  　\par
			\textbf{ジョイスティック}を\textbf{前後左右に倒す}ことにより, プレイヤーがスティックの動きに対応して移動する. 
			(例) ジョイスティックを右斜め前に倒すと, プレイヤーも右斜め方向に前進する. 
			\item[3Dビューとメニュー画面の切り替え]  　\par
			\textbf{ジョイスティック}の\textbf{スイッチを押し込む}ことでメニュー画面が表示される.
			スイッチを解放すると3Dビューの画面に戻る.
			\item[3Dビューの視点変更]  　\par
			\textbf{コリジョンセンサー}を\textbf{押しながら}, \textbf{基板}を\textbf{基板の縦方向を軸に左右へ傾ける}と, 
			傾けた角度に応じて3Dビューの視点が回転する.
			(例) コリジョンセンサーを押しながら基板を左手前へ30度傾けると, 3Dビューの視点が左方向へ30度回転する.
			\end{description}
			以降, ジョイスティックのスイッチやコリジョンセンサーを単にボタンとも呼称する.
	\item	スクリーン画面：ゲームの進行などに応じて基板上のOLED液晶ディスプレイに各画面が表示される.
			\begin{description}
			\item[タイトル画面]  　\par
			ゲームタイトルを表示し, プレイヤーにボタンの入力を求め, ゲーム開始を促す. (図\ref{title})
			\item[3Dビュー] 　\par
			ゲーム中のプレイヤーの位置・視点から見える視界を表示する. (図\ref{3D1},\ref{3D2})
			これにより, 視界に映る迷路の壁やアイテムとの位置関係が分かる.
			このとき, プレイヤー操作による位置の移動や視点の変更に応じて, 視界もリアルタイムに変化する.
			\item[メニュー画面] 　\par
			ゲーム中でのプレイヤーの向きや周囲の状況が俯瞰図で表示される.
			更に, 現時点での獲得アイテム数とクリアに必要な総アイテム数が表示される. (図\ref{menu})
			\item[クリア画面] 　\par
			クリアした旨を表示し, プレイヤーにボタンの入力を求め, タイトル画面への移行を促す. (図\ref{clear})
			\end{description}
\end{itemize}
\end{itembox}

\begin{itembox}[l]{3D迷路ゲームのゲームコンセプト (続き)}
\begin{itemize}
	\item	効果音：タイトル画面や画面切り替え時, 移動中, アイテム獲得時及びクリア時に, 
			それぞれに対応した効果音 (SE) を発生させる.
	\item	ゲームの進行： ``タイトル画面→ゲームプレイ→クリア画面'' の流れを繰り返す.
			ゲームプレイ中は, 3Dビューとメニュー画面が切り替え可能である.
\end{itemize}
\end{itembox}

\begin{figure}[h]
	\begin{tabular}{ccc}
	\begin{minipage}[t]{0.33\textwidth}
		\centering
		\includegraphics[width = 0.85\textwidth]{title.png}
		\caption{タイトル画面}
 		\label{title}
	\end{minipage} &
	\begin{minipage}[t]{0.33\textwidth}
		\centering
		\includegraphics[width = 0.85\textwidth]{3Dview1.png}
		\caption{3Dビューの例(1)}
 		\label{3D1}
	\end{minipage} &
	\begin{minipage}[t]{0.33\textwidth}
		\centering
		\includegraphics[width = 0.85\textwidth]{3Dview2.png}
		\caption{3Dビューの例(2)}
 		\label{3D2}
	\end{minipage}
	\end{tabular}
\end{figure}

\begin{figure}[h]
	\begin{tabular}{cc}
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\includegraphics[width = 0.55\textwidth]{menu.png}
		\caption{メニュー画面}
 		\label{menu}
	\end{minipage} &
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\includegraphics[width = 0.55\textwidth]{clear.png}
		\caption{クリア画面}
	 	\label{clear}
	\end{minipage}
	\end{tabular}
\end{figure}

続いて, 私が作成したゲームシステムの仕様を以下で説明する.

\begin{itembox}[l]{3D迷路ゲームシステムの仕様}
\begin{itemize}
	\item	初期状態：本システムの初期状態は, ゲームの開始を待機する\textbf{待機状態}とする.
	\item	状態：本システムは, ゲームの進行により, 以下の3つの状態を持つ.
			\begin{description}
			\item[待機状態]	　\par
			この状態ではタイトル画面を表示し, ゲームの開始を待機する.
			ゲームの開始はいずれかのボタンの押下を検知して判定する.
			\item[プレイ状態]　\par
			この状態ではゲームを実行し, プレイヤーの操作に従い, 移動や視点変更, アイテム獲得, メニュー画面への切り替えなど
			を行う.
			\item[クリア状態]　\par
			この状態ではタイトル画面への移行を待機する.
			タイトルへの移行はいずれかのボタンの押下を検知して判定する.
			\end{description}
	\item	入力：コンセプト通り, ジョイスティックとコリジョンセンサー, 基板の傾きを入力として受け取る.
	\item	出力：本システムからの出力として, \textbf{効果音}と\textbf{画面表示}がある.
			効果音の出力はMP3プレイヤー (YX5200) を経由してスピーカーから, 画面表示はOLED液晶 (SSD1306)から行われる.
\end{itemize}
\end{itembox}

\section{ハードウェアの回路}

まず, 使用したモジュールを以下の表\ref{moju}に示す.
以降, 各モジュールは回路図上ではチップ名で表記し, レポート内では品目名で呼称する.

\begin{table}[h]
 \caption{使用したモジュール一覧}
 \label{moju}
 \centering
  \begin{tabular}{c l l}
  \multicolumn{1}{c}{品目}	&	\multicolumn{1}{c}{チップ名}	&	\multicolumn{1}{c}{モジュールの詳細}\\
   \hline \hline
   OLED液晶	&	SSD1306	&	0.96インチ, 4ピン, 白色, IIC (I2C) 方式\\
   \hline
   MP3プレーヤー	&	YX5200	&	microSDカードに記録されているMP3ファイルを再生可能\\
   \hline
   6軸センサー (IMU)	&	MPU6050	&	3軸方向の加速度及び角速度が取得可能, I2C方式\\
   \hline
   ジョイスティック	&	KS0008	&	方向入力が可能, スティックを押し込んでプッシュボタンとしても利用可能\\
   \hline
   コリジョンセンサー	&	KS0021	&	衝突判定が可能, 本ゲームではトリガーボタンとして利用\\
   \hline
  \end{tabular}
\end{table}

続いて, 以下の図\ref{kairo}に作成したゲーム機体のハードウェア回路を示す.

\begin{figure}[h]
	\centering
	\includegraphics[width = \textwidth]{kairo.png}
	\caption{作成したゲーム機体の回路図}
 	\label{kairo}
\end{figure}

\subsection{回路の説明}

初めに, 回路の配線や抵抗の効果・意味について説明する.

まず, MP3プレイヤー (YX5200) のシリアルポートである\textbf{RXピン}及び\textbf{TXピン}の電圧は$\bm{3.3\rm{[V]}}$である一方, 
Arduino側の出力電圧は$\bm{5\rm{[V]}}$であるため, $\bm{1\rm{[k\Omega]}}$の抵抗を介している. [\ref{MP3}]
これにより, Arduino側からの送信内容を正確にMP3プレイヤーのRXピンで受け取ることが可能となる.
MP3プレイヤーのTXピンからの送信内容については, 抵抗を介さずともArduino側で正しく受信できるため, 抵抗は不要となっている.

次に, I2C方式の配線について説明する.
今回使用した中でI2C方式通信を採用しているモジュールは, \textbf{OLED液晶 (SSD1306)}と\textbf{6軸センサー (MPU6050)}である.
この方式では, マスターデバイスであるArduino本体とスレイブデバイスである各モジュールを
\textbf{SCL}と\textbf{SDA}の2つのバス配線で接続する.
マスターがSCLバスを通じてクロック信号をスレイブ側へと送信し, 
これを基にSDAバスを通じてマスター・スレイブ間でデータを送受信することが出来る.
SCLバス及びSDAバスはプルアップされる必要があるが, ArduinoのI2C方式通信に必要なWire.hライブラリを使用すると
自動的に内部プルアップ抵抗が使用されるため, 必ずしも外部プルアップ抵抗は必要ではない.
今回は通信の安定性を高めるため, 外部プルアップ抵抗として$\bm{10\rm{[k\Omega]}}$の抵抗を電源電圧$5\rm{[V]}$との間に介している.

また, 本来スイッチにはプルアップ抵抗が必要となるが, ジョイスティックのスイッチ (KS0008) やコリジョンセンサー (KS0021) には
既に内部に抵抗が組み込まれているため外部プルアップ抵抗が必要ではない.

\subsection{取得・出力できる情報とその形式の説明}

続いて, 各モジュールから取得・出力できる情報及びその形式や方法について説明する.

まず, ジョイスティックはVピンに電源電圧$5\rm{[V]}$, GピンにGNDを接続することで, 
ティックの傾けている方向及びボタンの状態が他の3つのピンから取得できる.
Xピン及びYピンは, スティックの傾いているX軸方向・Y軸方向の成分を0から1024までのアナログ信号で出力する.
\textbf{512}の値がスティック中央 (傾けていない場合) の時の信号値であり, 
X軸・Y軸について正の方向に倒していくと\textbf{512から1024まで}, 負の方向に倒していくと\textbf{512から0まで}信号値が変化する. 
更に, Bピンはボタンが押下されているならば\textbf{``1''}, 解放されていれば\textbf{``0''}を出力する.
Xピン及びYピンはArduino本体のアナログピンであるA0ピン・A1ピンに接続し, BピンはデジタルピンであるD6ピンに接続し, 
これらのピンからジョイスティックの情報を取得する.

一方で, コリジョンセンサーはVピンに電源電圧, GピンにGNDを接続することで, Sピンからセンサーのトリガーボタンの押下が検知できるが, 
ジョイスティックのプッシュボタンの論理とは逆になっている.
すなわち, Sピンはトリガーボタンの押下で\textbf{``0''}, 解放で\textbf{``1''}を出力する.
SピンをD7ピンに接続し, このデジタルピンからArudino本体はコリジョンセンサーの状態を取得できる.

次に, MP3プレイヤーはVCCピンに電源電圧, GNDピンにGNDを接続し, 
RXピン・TXピンをArduino本体のデジタルピンD3ピン・D2ピンと繋ぐことで, 
シリアル通信によりArudino側でMP3プレイヤーを制御でき, セットされているmicroSDカードのMP3データを再生することができる.
スピーカーの+端子及び-端子は, MP3プレーヤーのSPK\_1ピン・SPK\_2ピンに接続することで
音を表すアナログ信号が+端子へと出力され, スピーカーからMP3データが音として出力される.
シリアル通信における制御には\textbf{Paul Stoffregen氏のSoftwareSerial.hライブラリ}を, 
MP3プレイヤーの制御には\textbf{DFRobot社のDFRobotDFPlayerMini.hライブラリ}を使用した.

続いて, OLED液晶はVCCピンに電源電圧, GNDピンにGNDを接続し, 
SCLピン及びSDAピンをArduino本体のSCLピン及びSDAピンと繋がっているSCLバス・SDAバスと接続している. 
これにより, I2C方式の通信が行え, Arduino本体からOLED液晶を制御して画面の表示を行うことができる.
レジスタの読み込みや書き込み等の通信処理には\textbf{oliver氏のU8glib.hライブラリ}を使用した.

同様に, 6軸センサーもVCCピンに電源電圧, GNDピンにGNDを接続し, 
SCLピン及びSDAピンをArduino本体のSCLピン及びSDAピンと繋がっているSCLバス・SDAバスと接続している. 
6軸センサー (MPU6050) にはDMPと呼ばれるセンサーの姿勢角の情報を算出する内部機能があり,
DMPのIC回路によって, 誤差の少ない角度情報を取得することが可能となっている.
今回は, DMPを用いて, 姿勢角の情報に対応するクォータニオンを取得し処理を行った.
I2C方式通信によるDMPの有効設定や6軸センサーからのクォータニオンの取得処理, 及びクォータニオンの計算処理には
\textbf{Electronic Cats社のMPU6050\_6Axis\_MotionApps20.h}ライブラリを使用した.

\subsection{各モジュールの配置及びゲーム機体のデザイン}

最後に, 基板上での各モジュールの配置 (ゲーム機体のデザイン) について説明する.

まず, 各モジュールの配置を図\ref{hard}に示す.
右上にコリジョンセンサー, 中央にOLED液晶, その左隣に6軸センサー, 左上にジョイスティックが配置されている.
また, 右下にはArduino本体, その左隣にMP3プレイヤー, 左端にスピーカーが固定されている.

\begin{figure}[h]
	\centering
	\includegraphics[width = 0.7\textwidth]{hard1.png}
	\caption{モジュールの配置及びゲーム機体のデザイン}
	\label{hard}
\end{figure}

基板 (ブレッドボード) をゲーム機体と見なした場合, 重視すべき点として\textbf{``配線やモジュールが固定され, 安定しているか''}と
\textbf{``手に持った時の操作が容易であるか''}の2点を私は考えた.

まず, 前者について説明する.
プレイヤーがスティックやボタンを操作し, 基板を傾ける際に, 各モジュールや配線が固定されていないと操作がしづらいことが考えられる.
また, モジュール・配線が不安定であると, 基板から部品が落下する, 部品の接触が悪くなりゲームにノイズが発生する, 
または進行不能となる等の様々な悪影響が考えられる.
これらを回避するため, 図\ref{lock}のようにモジュールのピンを基板へしっかり差し込むだけでなく, 
モジュールや配線自体を基板にテープで固定し, 安定性を高めた.

次に, 後者について説明する.
基板 (ゲーム機体) を手にしたとき, 指が置かれる位置に操作用のモジュールがないと, 操作性が悪いことが考えられる.
指が置かれる位置としては, 基板の右上の端・左上の端とそれらの基板の縁が挙げられる.
ここで, 携帯ゲーム機の大半がジョイスティックを左に, トリガーボタンを機体の縁に設置していることを参考に, 
図\ref{hard}で示したようにジョイスティックを左上の端に, コリジョンセンサーを基板右上の縁に設置することにより, 
図\ref{playnow}のようにプレイヤーが操作しやすい基板のデザインにすることが出来た.

\begin{figure}[h]
	\begin{tabular}{cc}
	\begin{minipage}[t]{0.46\textwidth}
		\centering
		\includegraphics[width = \textwidth]{lock.png}
		\caption{配線及びモジュールの固定}
 		\label{lock}
	\end{minipage} &
	\begin{minipage}[t]{0.545\textwidth}
		\centering
		\includegraphics[width = \textwidth]{playnow.png}
		\caption{プレイ中の様子}
	 	\label{playnow}
	\end{minipage}
	\end{tabular}
\end{figure}

終わりに, 基板に配置した際のジョイスティック及び6軸センサーの軸の向きを以下の表\ref{direct}にまとめる.

\begin{table}[h]
 \caption{モジュールの軸と基板上での方向の対応}
 \label{direct}
 \centering
  \begin{tabular}{c l l}
  \multicolumn{1}{c}{品目}	&	\multicolumn{1}{c}{方向軸}	&	\multicolumn{1}{c}{基板上での方向}\\
   \hline \hline
   \multirow{2}{*}{ジョイスティック}	&	\textbf{X軸正}の方向		&	基板の\textbf{水平右方向}\\
   	&	\textbf{Y軸正}の方向		&	基板の\textbf{水平上方向}\\
   \hline
  \multirow{3}{*}{ 6軸センサー (IMU)}	&	\textbf{X軸正}の方向		&	基板の\textbf{水平下方向}\\
  	&	\textbf{Y軸正}の方向		&	基板の\textbf{水平右方向}\\	
  	&	\textbf{Z軸正}の方向		&	基板の\textbf{垂直上方向}\\	
   \hline
  \end{tabular}
\end{table}

\section{ゲームプログラムの設計方法}

本節では, 作成したゲームプログラムのアルゴリズムを説明する.

まず, プログラムがゲーム進行の制御処理を行う前のセットアップ処理について説明する.
ゲームプログラムは以下に示す処理を起動直後に1度だけ行う.

\begin{description}
\item[MP3プレイヤー]　\textbf{シリアル通信の開始}
		\begin{itemize}
		\item	SoftwareSerialクラスのインスタンスを生成してRX・TXピンにD2ピン・D3ピンを指定し, 
				通信速度を9600bpsに設定.
		\item	生成したインスタンスをDFRobotDFPlayerMini.hライブラリのDFRobotDFPlayerMiniクラスのインスタンスに
				渡し, MP3プレイヤーの制御処理を開始する.
		\end{itemize}
	
\item[OLED液晶]　\textbf{I2C通信の開始及び各種表示設定}
		\begin{itemize}
		\item	U8GLIB\_SSD1306\_128X64クラスのインスタンスを生成し, 
				I2C方式によるOLED液晶との通信を開始する.
		\item	生成したインスタンスのメソッドを利用し, フォントの大きさや形式, 描画する色等を設定する.
		\end{itemize}
	
\item[6軸センサー]　\textbf{I2C通信の開始及び各種表示設定}
		\begin{itemize}
		\item	MPU6050クラスのインスタンスを生成し, I2C方式による6軸センサーとの通信を開始する.
		\item	生成したインスタンスのメソッドを利用し, DMPの有効化を行う.
				成功した場合は姿勢角の算出時に生じるバイアス (誤差) を較正する頻度を指定する.
		\item	ライブラリのサンプルスケッチ ``IMU\_Zero''の実行結果より得た, 
				3軸加速度・ジャイロセンサーのオフセット値を指定してセンサーを校正する.	[\ref{DMP}]
		\end{itemize}
	
\item[その他]　\textbf{単位ベクトルの設定}
		\begin{itemize}
		\item	X軸とベクトルの成す角が0度から3度刻みで45度までとなる, 計$45/3+1=\bm{16}$個の単位ベクトルを求める.
				それぞれの角の正弦 (sin) ・余弦 (cos) の組を順に求め, 
				本プログラム独自のクラスであるVector2Dクラス配列にこれらの組を格納する.
		\end{itemize}
	
\end{description}

ここで, 16個の単位ベクトルについて捕捉する.
0度から45度までとしているのは, 三角関数の性質からこれらの正弦・余弦の組の値だけで
360度全ての角の正弦・余弦が求まるからである.
具体的には以下のような理由である.

\begin{screen}
まず, 45度から90度までの正弦・余弦の値については, $ sin \theta = cos ( 90\tcdegree - \theta ) $,  
$cos \theta = sin ( 90\tcdegree - \theta ) $ より, 0度から45度までの正弦・余弦の値を用いて求められる.
次に, 90度から180度までの正弦・余弦の値については, $ sin \theta = sin ( 180\tcdegree - \theta ) $,  
$cos \theta = - cos ( 180\tcdegree - \theta ) $ より, 0度から90度までの正弦・余弦の値を用いて求められる.
最後に, 180度から360度までの正弦・余弦の値については, $ sin \theta = - sin ( 360\tcdegree - \theta ) $,  
$cos \theta = cos ( 360\tcdegree - \theta ) $ より, 0度から180度までの正弦・余弦の値を用いて求められる.
従って, 0度から45度までの正弦・余弦の値の組があれば, 0度から360度までの全方向の角について正弦・余弦の値が求まる.
\end{screen}

また, 今回のゲームシステムの実装では, 視点変更並びにレイキャスティング (後述) における光線の間隔が3度刻みであるため, 
0度から3度刻みで45度までの16個の正弦・余弦の組だけでよい.
これらの値は, 単に正弦・余弦の値として使う, レイキャスティングの光線の処理に利用する等, 
本プログラム内で多種多様な用途で使用される.

以上のセットアップ処理を行った後, \textbf{ゲームのリセット処理}を行う.
具体的には, ゲームの進行状態の初期化や迷路の構成, プレイヤーの位置・視点の初期化, アイテムの配置等である.
リセット処理の後, ゲームの進行処理へと移る.
これについては次で説明する

\subsection{ゲームの進行処理}

ゲームの進行状態は, 以下の図\ref{game}のように, 3つに分類される.

\begin{figure}[h]
	\centering
	\includegraphics[width = 0.7\textwidth]{game.png}
	\caption{ゲームの進行に関する状態遷移}
 	\label{game}
\end{figure}

待機状態$S_0$では, MP3プレイヤーとOLED液晶と制御し, タイトル画面で流すSEをループさせ, 
タイトルとボタンの入力を促す旨を画面に出力する.
SEにはフリーの効果音[\ref{a}]の演出・アニメ用素材である ``拍子木1''を選んだ.
ボタンの押下を検知した後, SEのループを終了し, プレイ状態$S_1$へ移行する.

次に, プレイ状態$S_1$では, 3D迷路ゲームのプレイ中の処理を行う.
プレイヤーの情報を格納しているPlayerクラスのインスタンスを参照し, 獲得アイテムの数が総アイテム数と等しくなった場合,
クリア状態$S_2$へと移行する.
3D迷路ゲームプレイ中の処理の詳細は後で詳しく説明する.

最後に, クリア状態$S_2$では, MP3プレイヤーとOLED液晶と制御し, クリア時に流すSEを再生し, 
クリアとボタンの入力を促す旨を画面に出力する.
SEにはフリーの効果音[\ref{a}]の演出・アニメ用素材である ``レベルアップ''を選んだ.
ボタンの押下を検知した後,  ゲームのリセット処理を行い, 待機状態$S_0$へ移行する.

\subsection{プレイ状態における処理}

続いて, プレイ状態における処理は, 図\ref{play}のように, 2つの状態を用いて表現できる.
状態$Q_0$は3Dビューの描画処理, $Q_1$はメニュー画面の描画処理と対応している.

\begin{figure}[h]
	\centering
	\includegraphics[width = 0.5\textwidth]{play.png}
	\caption{プレイ状態$\bm{S_1}$における内部の状態遷移}
 	\label{play}
\end{figure}

まず, 両状態で共通の処理に\textbf{``プレイヤーの位置移動''}と\textbf{``アイテムの獲得''}, 
\textbf{``プレイヤーの視点変更''}がある.

\textbf{位置移動}については, ジョイスティックの入力をプレイヤーの視点角 (視野の中心角) を基に, 
マップ上のX成分・Y成分に分割し, プレイヤーの座標にこれらを加算する.
移動する場合, すなわちマップ上のX成分・Y成分の値が大きい場合は, 
フリーの効果音[\ref{a}]の生活カテゴリ内の ``アスファルトの上を歩く1'' のSEをループ再生させ, 歩いている臨場感が出るようにした.

\textbf{アイテムの獲得}では, 未獲得のアイテムとの距離を算出し, この距離が基準未満であるものを獲得する.
アイテムを獲得すると, アイテムの獲得情報を更新し, 現獲得アイテムが総アイテム数と等しい場合は状態$S_2$へ移行する.
また, アイテムの獲得時には, SEとしてフリーの効果音[\ref{a}]の演出・アニメ用素材である ``ピアノの単音''を流す.

\textbf{視点変更}については, 6軸センサーから取得できる\textbf{クォータニオン}を用いて処理を行った.
具体的な処理手順は以下の通りである.

\begin{enumerate}[手順(1)]
\item	コリジョンセンサーが押下されていない場合, 6軸センサーから最新の姿勢角を表すクォータニオンを取得し, 
		クォータニオンの変数$\bm{q_{pre}}$を最新のクォータニオンに更新する.
		また, 現在の視点角を保持しておく.
\item	コリジョンセンサーが押下されている間,  6軸センサーから現在のクォータニオンを取得し, これを$\bm{q_{cur}}$に格納する.
		この$\bm{q_{cur}}$と$\bm{q_{pre}}$から視点変更のオフセット角を表すクォータニオン$\bm{q_{off}}$を取得し, 
		$\bm{q_{off}}$を用いてY軸についての回転角を得る.
		求めた回転角と保持している視点角を加算したものを現在の視点角として更新する.
		但し, このときの度数法による角度の値は3の倍数 (3度刻み) となるように, 値を丸める.
\item	コリジョンセンサーが解放された場合, 現在の視点角を確定させ, 視点変更の処理を終了する.
\end{enumerate}

\begin{itembox}[l]{オフセット角を表すクォータニオン$\bm{q_{off}}$の求め方}
図\ref{qua}に示す通り, $\bm{q_{cur}}, \bm{q_{pre}}, \bm{q_{off}}$について, 以下の等式が成立する.
\begin{equation*}
q_{cur} = q_{off} \otimes q_{pre}
\end{equation*}
ここで, $q_{pre}$は単位クォータニオンであり, これの共役$q_{pre}^{*}$は$q_{pre}$の逆クォータニオンである.
従って, 
\begin{equation*}
q_{cur} \otimes q_{pre}^{*} = q_{off} \otimes q_{pre} \otimes q_{pre}^{*} = q_{off} \otimes (q_{pre} \otimes q_{pre}^{-1}) =  q_{off} 
　　　\therefore	\bm{q_{off} = q_{cur} \otimes q_{pre}^{*}} 
\end{equation*}
以上より, 最後に求めた式より, $\bm{q_{off}}$が求まる.
クォータニオンの計算並びにクォータニオンが表すオフセット角 (姿勢角) の算出には
6軸センサーのライブラリ内で実装されているものを利用した.
\end{itembox}

\begin{figure}
	\centering
	\includegraphics[width = 0.5\textwidth]{quatanion.png}
	\caption{視点変更におけるオフセット角を表すクォータニオンの求め方}
 	\label{qua}
\end{figure}

次に, 状態$Q_0$では, \textbf{レイキャスティング}[\ref{lay}]を用いて, 二次元のプレイヤー座標や迷路マップの情報から
3Dビューの画面を描画する.
レイキャスティングは以下の手順で実行される.
以下, 視点角 (向いている方向) を$\alpha$, 視野角を$\beta$, 光線の間隔の角を$\omega$とする.

\begin{enumerate}[手順(1)]
\item	図\ref{distort1}, \ref{distort2}の左に示されるように, 
		プレイヤーの位置を始点として, 視点角$\alpha$から左右に$\frac{\beta}{2}$, 
		全てで$\beta$の範囲を$\omega$毎に分割する. 
		範囲の端と分割時に引いた線をプレイヤーの座標から発射された光線とみなす.
		光線数$n$は, $n = \beta/\omega + 1$であり, 各光線$l_i ( 1 \leq i \leq n , 右端がi=1)$, 
		視点角$\alpha$と光線$l_i$が成す角を$\theta_i$とする.
\item	発射した各光線$l_i$について, 迷路の壁との交点を求め, 最も初めに衝突した交点とプレイヤーとの距離$d_i$を算出する.
		プレイヤーから遠くに存在する壁は遠近法の考えでは3Dビュー上で見えなくなるため, 
		$d_i$が大きい場合は, 壁との交点を発見出来なかったと判断する.
\item	各光線$l_i$について求めた距離$d_i$を用いて, 描画に用いる壁の高さを決定する.
		遠くのものほど小さく映ればよいため, 壁の高さは$d_i$に反比例させればよい.
		但し, 算出した距離をそのまま用いると図\ref{distort1}のように歪みが発生するため, 
		各光線$l_i$と視点角$\alpha$が成す角である$\theta_i$の余弦の値と$d_i$の積を取った値に反比例するように
		壁の高さを決定する.
		交点が発見できなかった場合は, $h_i = 0 $ (壁が見えない) と設定する.
		\begin{equation*}
		壁の高さ h_i = \frac{定数}{d_i \times cos\theta_i}
		\end{equation*}
\item	図\ref{distort2}の右に示されるように, 壁の高さ$h_i$に基づき, 右端から左端まで画面に描画する.
		そのあとに, 未獲得のアイテムとの距離及び視点角$\alpha$との成す角を求め, このアイテムが視界内かつ
		プレイヤーとアイテムの間に壁が存在しないことを先の手順で求めた$d_i$などの情報を用いて決定し, 
		壁を描画した上からアイテムを描画する.
		アイテムの大きさもプレイヤーとの距離に反比例させて, 遠いものほど小さく映るようにする.
\end{enumerate}

\begin{figure}[h]
	\begin{tabular}{cc}
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{distort1.png}
		\caption{前面に壁がある場合の歪み}
 		\label{distort1}
	\end{minipage} &
	\begin{minipage}[t]{0.49\textwidth}
		\centering
		\includegraphics[width = \textwidth]{distort2.png}
		\caption{歪み補正した後の3Dビュー}
	 	\label{distort2}
	\end{minipage}
	\end{tabular}
\end{figure}

以上の手順により, 図\ref{3D1}及び\ref{3D2}のような3Dビューの画面が描画できる.

一方で, 状態$Q_1$では, メニュー画面を表示する.
図\ref{menu}で示した通り, メニュー画面の右側には現獲得アイテム数とクリアに必要な総アイテム数を表示し,
左側にはプレイヤーを中心として周囲の迷路の様子を表した俯瞰図を表示させている.
俯瞰図の描画は, プレイヤーの位置情報から対応する迷路の二次元データの添字の組を獲得し, 
これを利用して, 壁もしくは道かを1マスずつ判断し塗りつぶしている.
その後, プレイヤーの視点角や未獲得アイテムの所在位置情報を取得し, これらを基にプレイヤー・アイテムをマップに描画する.

以上の2状態$Q_0,Q_1$を, ジョイスティックのプッシュボタンの押下・解放によって切り替えることで, 
3D迷路ゲームにおける3Dビューとメニュー画面の切り替えを可能にした.
また, 状態$Q_0$から$Q_1$へ移行する際には, フリーの効果音[\ref{a}]の演出・アニメ用素材である ``シーン切り替え1'' を流した.

\section{考察・工夫点}

本課題を通して, システムを仕様からハードウェア, 制御プラグラムに至るまで全て自力で作成することを経験した.
本課題のようなシステムを全て一から考えて作り上げる経験は, 今回が初めてであったので,
システムの仕様の重要性を身をもって実感することが出来た.
仕様の整合性がとれていてある程度細かく定まっていないと, ハードウェア・制御プログラムの開発において
開発内容にずれや不具合が生じて開発に支障をきたすため, 十分留意して仕様を決定する必要があると学んだ.
特に, 私が作成したような規模の大きなシステムとなると, 開発における仕様の重要性は顕著であったと考えられる.

また, 今回作成した ``3D迷路ゲーム'' は \textbf{``処理速度''}, \textbf{``メモリ量''}, \textbf{``デザイン''}の3つの点において,
工夫を有していると考察できる.
それぞれにおける具体的な工夫の例や詳細は, 以下に示す.

\begin{itembox}[l]{工夫点の詳細}
\begin{description}
\item[処理速度]　\par
単位ベクトルを予め求めておくことにより, レイキャスティングにおける各光線の角の正弦・余弦の値を高速に求めることが出来る.
sin関数及びcos関数によって正弦・余弦を求める際は, 高い計算コストを要するが,
予め求めた値にアクセスする場合は関数を用いて計算する時と比較して非常に高速に処理が行える.
他にも, プレイヤーの移動やアイテムとの位置関係の把握などの処理でも正弦・余弦の値が必要となるため,
正弦・余弦の値を用いる処理は多種多様な用途で頻繁に発生することが分かる.
従って, 単位ベクトルを予め求めることで正弦・余弦の算出一回が高速に行えるため, 全体の処理速度が向上する.

\item[メモリ量]　\par
メモリ量の節約は, 予め算出している単位ベクトルの個数に特に表れている.
三角関数の性質を用いることで, 本来$360/3=\bm{120}$\textbf{個}必要となる単位ベクトルを
\textbf{16個 (約$\frac{\bm{1}}{\bm{8}}$)}まで削減することが出来た.
また, OLED液晶に出力するためのライブラリの選出にも気を配り, 他のライブラリだとフラッシュメモリやメインメモリに書き込まれる
メモリ量が多く動作しないことがあったため, ``U8glib.h''ライブラリを使用した.
以上の工夫によって以下のように正常に動作できるだけのメインメモリを確保することが出来た.

\item[デザイン]　\par
ゲーム機体やゲームデザインからも分かるように, プレイしやすさ・分かりやすさを考えて, ゲームを作成した.
ゲーム機体については, 携帯ゲーム機 (任天堂の3DS等) を参考に, トリガーボタンを基板の縁寄りに配置し, 
ジョイスティックを基板左側に配置し, 更に画面が見やすいようにOLED液晶は中央に配置した.
また, 3DSから着想を得て, 6軸センサーを用いて基板の傾きから視点を移動させることを思いついた.
このような工夫により, プレイヤーが初めてでも直感的にプレイしやすいゲーム機体を設計できたと考えられる.
一方で, ゲームデザインは, メニュー画面でのアイテム数や俯瞰図の情報によって, 
プレイヤーが置かれている状況が逐次確認できるため, 分かりやすいものとなっていると考えられる.
更に, 各場面や動作に応じて流れるSEもゲームへの没入感を高める効果があり, 
ゲームの完成度をより高める要因となっていると考察できる.

\end{description}
\end{itembox}

\section{感想}

本課題では, 実際にゲーム開発を経験し, ゲームを制作する大変さを身に染みて理解することが出来た.
考察でも述べたように, 仕様・ハードウェア・制御プログラムの一連の開発で, 
それぞれの開発内容でかみ合わなくなる箇所が発生する等, 一からゲーム開発することの難しさを体感できた.
また, バグや予期せぬ挙動も多数発生したため, これらを取り除くのに非常に苦労した.

また, Youtubeの動画や普段の授業・勉強の中から学んだ内容であるレイキャスティング[\ref{lay}]やクォータニオンといった
概念やテクニックを利用することで, 実際のプログラム作成に活用することが出来た.
自分の知識を実践し, 生きた知識とすることが出来て, 良い経験となったと感じた.
今後も, 自分の知識を実践する機会を積極的に活用し, 血となり肉となるように努めていきたい.

\section{使用素材・参考文献}

\begin{enumerate}[\textrm{[}1\textrm{]}]
\item	DFRobot WIKI EN, DFR0299 DFPlayer Mini (\url{https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299})	\label{MP3}
\item	MPU6050のDMPを使う, Qiita, Ninagawa\_Izumi氏, (\url{https://qiita.com/Ninagawa_Izumi/items/2646c7d3d98943919f80})	\label{DMP}
\item	効果音ラボ (\url{https://soundeffect-lab.info/})		\label{a}
\item	高校数学とJavaScriptだけ。FPSの作り方 \#1 ～ \#3, ヘロンの数学チャンネル (\url{https://t.co/jgoROJ14f5}) \label{lay}
\end{enumerate}

\end{document}